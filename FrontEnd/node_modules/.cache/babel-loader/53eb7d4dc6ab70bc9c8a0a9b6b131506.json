{"ast":null,"code":"import _classCallCheck from \"D:/SwitMe/FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"D:/SwitMe/FrontEnd/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";\n\n/**\n * @internal\n */\nvar NULL = 0;\n/**\n * @internal\n */\n\nvar LF = 10;\n/**\n * @internal\n */\n\nvar CR = 13;\n/**\n * @internal\n */\n\nvar COLON = 58;\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\n\nexport var Parser = /*#__PURE__*/function () {\n  function Parser(onFrame, onIncomingPing) {\n    _classCallCheck(this, Parser);\n\n    this.onFrame = onFrame;\n    this.onIncomingPing = onIncomingPing;\n    this._encoder = new TextEncoder();\n    this._decoder = new TextDecoder();\n    this._token = [];\n\n    this._initState();\n  }\n\n  _createClass(Parser, [{\n    key: \"parseChunk\",\n    value: function parseChunk(segment) {\n      var appendMissingNULLonIncoming = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;\n      var chunk;\n\n      if (segment instanceof ArrayBuffer) {\n        chunk = new Uint8Array(segment);\n      } else {\n        chunk = this._encoder.encode(segment);\n      } // See https://github.com/stomp-js/stompjs/issues/89\n      // Remove when underlying issue is fixed.\n      //\n      // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n\n\n      if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n        var chunkWithNull = new Uint8Array(chunk.length + 1);\n        chunkWithNull.set(chunk, 0);\n        chunkWithNull[chunk.length] = 0;\n        chunk = chunkWithNull;\n      } // tslint:disable-next-line:prefer-for-of\n\n\n      for (var i = 0; i < chunk.length; i++) {\n        var byte = chunk[i];\n\n        this._onByte(byte);\n      }\n    } // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n\n  }, {\n    key: \"_collectFrame\",\n    value: function _collectFrame(byte) {\n      if (byte === NULL) {\n        // Ignore\n        return;\n      }\n\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n\n      if (byte === LF) {\n        // Incoming Ping\n        this.onIncomingPing();\n        return;\n      }\n\n      this._onByte = this._collectCommand;\n\n      this._reinjectByte(byte);\n    }\n  }, {\n    key: \"_collectCommand\",\n    value: function _collectCommand(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n\n      if (byte === LF) {\n        this._results.command = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaders;\n        return;\n      }\n\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectHeaders\",\n    value: function _collectHeaders(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n\n      if (byte === LF) {\n        this._setupCollectBody();\n\n        return;\n      }\n\n      this._onByte = this._collectHeaderKey;\n\n      this._reinjectByte(byte);\n    }\n  }, {\n    key: \"_reinjectByte\",\n    value: function _reinjectByte(byte) {\n      this._onByte(byte);\n    }\n  }, {\n    key: \"_collectHeaderKey\",\n    value: function _collectHeaderKey(byte) {\n      if (byte === COLON) {\n        this._headerKey = this._consumeTokenAsUTF8();\n        this._onByte = this._collectHeaderValue;\n        return;\n      }\n\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectHeaderValue\",\n    value: function _collectHeaderValue(byte) {\n      if (byte === CR) {\n        // Ignore CR\n        return;\n      }\n\n      if (byte === LF) {\n        this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n\n        this._headerKey = undefined;\n        this._onByte = this._collectHeaders;\n        return;\n      }\n\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_setupCollectBody\",\n    value: function _setupCollectBody() {\n      var contentLengthHeader = this._results.headers.filter(function (header) {\n        return header[0] === 'content-length';\n      })[0];\n\n      if (contentLengthHeader) {\n        this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n        this._onByte = this._collectBodyFixedSize;\n      } else {\n        this._onByte = this._collectBodyNullTerminated;\n      }\n    }\n  }, {\n    key: \"_collectBodyNullTerminated\",\n    value: function _collectBodyNullTerminated(byte) {\n      if (byte === NULL) {\n        this._retrievedBody();\n\n        return;\n      }\n\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_collectBodyFixedSize\",\n    value: function _collectBodyFixedSize(byte) {\n      // It is post decrement, so that we discard the trailing NULL octet\n      if (this._bodyBytesRemaining-- === 0) {\n        this._retrievedBody();\n\n        return;\n      }\n\n      this._consumeByte(byte);\n    }\n  }, {\n    key: \"_retrievedBody\",\n    value: function _retrievedBody() {\n      this._results.binaryBody = this._consumeTokenAsRaw();\n      this.onFrame(this._results);\n\n      this._initState();\n    } // Rec Descent Parser helpers\n\n  }, {\n    key: \"_consumeByte\",\n    value: function _consumeByte(byte) {\n      this._token.push(byte);\n    }\n  }, {\n    key: \"_consumeTokenAsUTF8\",\n    value: function _consumeTokenAsUTF8() {\n      return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n  }, {\n    key: \"_consumeTokenAsRaw\",\n    value: function _consumeTokenAsRaw() {\n      var rawResult = new Uint8Array(this._token);\n      this._token = [];\n      return rawResult;\n    }\n  }, {\n    key: \"_initState\",\n    value: function _initState() {\n      this._results = {\n        command: undefined,\n        headers: [],\n        binaryBody: undefined\n      };\n      this._token = [];\n      this._headerKey = undefined;\n      this._onByte = this._collectFrame;\n    }\n  }]);\n\n  return Parser;\n}();","map":{"version":3,"sources":["../src/parser.ts"],"names":[],"mappings":"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","sourceRoot":"","sourcesContent":["/**\n * @internal\n */\nconst NULL = 0;\n/**\n * @internal\n */\nconst LF = 10;\n/**\n * @internal\n */\nconst CR = 13;\n/**\n * @internal\n */\nconst COLON = 58;\n/**\n * This is an evented, rec descent parser.\n * A stream of Octets can be passed and whenever it recognizes\n * a complete Frame or an incoming ping it will invoke the registered callbacks.\n *\n * All incoming Octets are fed into _onByte function.\n * Depending on current state the _onByte function keeps changing.\n * Depending on the state it keeps accumulating into _token and _results.\n * State is indicated by current value of _onByte, all states are named as _collect.\n *\n * STOMP standards https://stomp.github.io/stomp-specification-1.2.html\n * imply that all lengths are considered in bytes (instead of string lengths).\n * So, before actual parsing, if the incoming data is String it is converted to Octets.\n * This allows faithful implementation of the protocol and allows NULL Octets to be present in the body.\n *\n * There is no peek function on the incoming data.\n * When a state change occurs based on an Octet without consuming the Octet,\n * the Octet, after state change, is fed again (_reinjectByte).\n * This became possible as the state change can be determined by inspecting just one Octet.\n *\n * There are two modes to collect the body, if content-length header is there then it by counting Octets\n * otherwise it is determined by NULL terminator.\n *\n * Following the standards, the command and headers are converted to Strings\n * and the body is returned as Octets.\n * Headers are returned as an array and not as Hash - to allow multiple occurrence of an header.\n *\n * This parser does not use Regular Expressions as that can only operate on Strings.\n *\n * It handles if multiple STOMP frames are given as one chunk, a frame is split into multiple chunks, or\n * any combination there of. The parser remembers its state (any partial frame) and continues when a new chunk\n * is pushed.\n *\n * Typically the higher level function will convert headers to Hash, handle unescaping of header values\n * (which is protocol version specific), and convert body to text.\n *\n * Check the parser.spec.js to understand cases that this parser is supposed to handle.\n *\n * Part of `@stomp/stompjs`.\n *\n * @internal\n */\nexport class Parser {\n    constructor(onFrame, onIncomingPing) {\n        this.onFrame = onFrame;\n        this.onIncomingPing = onIncomingPing;\n        this._encoder = new TextEncoder();\n        this._decoder = new TextDecoder();\n        this._token = [];\n        this._initState();\n    }\n    parseChunk(segment, appendMissingNULLonIncoming = false) {\n        let chunk;\n        if (segment instanceof ArrayBuffer) {\n            chunk = new Uint8Array(segment);\n        }\n        else {\n            chunk = this._encoder.encode(segment);\n        }\n        // See https://github.com/stomp-js/stompjs/issues/89\n        // Remove when underlying issue is fixed.\n        //\n        // Send a NULL byte, if the last byte of a Text frame was not NULL.F\n        if (appendMissingNULLonIncoming && chunk[chunk.length - 1] !== 0) {\n            const chunkWithNull = new Uint8Array(chunk.length + 1);\n            chunkWithNull.set(chunk, 0);\n            chunkWithNull[chunk.length] = 0;\n            chunk = chunkWithNull;\n        }\n        // tslint:disable-next-line:prefer-for-of\n        for (let i = 0; i < chunk.length; i++) {\n            const byte = chunk[i];\n            this._onByte(byte);\n        }\n    }\n    // The following implements a simple Rec Descent Parser.\n    // The grammar is simple and just one byte tells what should be the next state\n    _collectFrame(byte) {\n        if (byte === NULL) {\n            // Ignore\n            return;\n        }\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            // Incoming Ping\n            this.onIncomingPing();\n            return;\n        }\n        this._onByte = this._collectCommand;\n        this._reinjectByte(byte);\n    }\n    _collectCommand(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._results.command = this._consumeTokenAsUTF8();\n            this._onByte = this._collectHeaders;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectHeaders(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._setupCollectBody();\n            return;\n        }\n        this._onByte = this._collectHeaderKey;\n        this._reinjectByte(byte);\n    }\n    _reinjectByte(byte) {\n        this._onByte(byte);\n    }\n    _collectHeaderKey(byte) {\n        if (byte === COLON) {\n            this._headerKey = this._consumeTokenAsUTF8();\n            this._onByte = this._collectHeaderValue;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectHeaderValue(byte) {\n        if (byte === CR) {\n            // Ignore CR\n            return;\n        }\n        if (byte === LF) {\n            this._results.headers.push([this._headerKey, this._consumeTokenAsUTF8()]);\n            this._headerKey = undefined;\n            this._onByte = this._collectHeaders;\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _setupCollectBody() {\n        const contentLengthHeader = this._results.headers.filter((header) => {\n            return header[0] === 'content-length';\n        })[0];\n        if (contentLengthHeader) {\n            this._bodyBytesRemaining = parseInt(contentLengthHeader[1], 10);\n            this._onByte = this._collectBodyFixedSize;\n        }\n        else {\n            this._onByte = this._collectBodyNullTerminated;\n        }\n    }\n    _collectBodyNullTerminated(byte) {\n        if (byte === NULL) {\n            this._retrievedBody();\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _collectBodyFixedSize(byte) {\n        // It is post decrement, so that we discard the trailing NULL octet\n        if (this._bodyBytesRemaining-- === 0) {\n            this._retrievedBody();\n            return;\n        }\n        this._consumeByte(byte);\n    }\n    _retrievedBody() {\n        this._results.binaryBody = this._consumeTokenAsRaw();\n        this.onFrame(this._results);\n        this._initState();\n    }\n    // Rec Descent Parser helpers\n    _consumeByte(byte) {\n        this._token.push(byte);\n    }\n    _consumeTokenAsUTF8() {\n        return this._decoder.decode(this._consumeTokenAsRaw());\n    }\n    _consumeTokenAsRaw() {\n        const rawResult = new Uint8Array(this._token);\n        this._token = [];\n        return rawResult;\n    }\n    _initState() {\n        this._results = {\n            command: undefined,\n            headers: [],\n            binaryBody: undefined,\n        };\n        this._token = [];\n        this._headerKey = undefined;\n        this._onByte = this._collectFrame;\n    }\n}\n//# sourceMappingURL=parser.js.map"]},"metadata":{},"sourceType":"module"}